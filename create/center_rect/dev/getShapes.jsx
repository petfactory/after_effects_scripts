function inside(point, vs){    // ray-casting algorithm based on    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html        var x = point[0], y = point[1];        var inside = false;    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {        var xi = vs[i][0], yi = vs[i][1];        var xj = vs[j][0], yj = vs[j][1];                var intersect = ((yi > y) != (yj > y))            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);        if (intersect) inside = !inside;    }        return inside;};function get_verts(shape_layer){    var ret_list = []     // Iterate over the shape layer's paths, converting them to masks    var shapeContents = shape_layer.property("ADBE Root Vectors Group");        for (var g=1; g<=shapeContents.numProperties; g++)    {        shapeGroup = shapeContents.property(g);                // Only process groups        if (shapeGroup.matchName !== "ADBE Vector Group") continue;                shape_trans_pos = shapeGroup.property("ADBE Vector Transform Group").property("ADBE Vector Position").value;        shape_trans_anchor = shapeGroup.property("ADBE Vector Transform Group").property("ADBE Vector Anchor").value;        layer_trans_pos = shape_layer.transform.position.value;        layer_trans_anchor = shape_layer.transform.anchorPoint.value;                    // Look in each group for shape paths. These will be converted to masks        shapeGroupContents = shapeGroup.property("Contents");                for (var gp=1; gp<=shapeGroupContents.numProperties; gp++)        {            shapeGroupProp = shapeGroupContents.property(gp);            if (shapeGroupProp.matchName === "ADBE Vector Shape - Group")            {                try                {                    // Get the shape path info                    shapePath = shapeGroupProp.property("ADBE Vector Shape");                    verts = shapePath.value.vertices;                                        var info = {};                    info.name = shapeGroup.name;                    var temp = [];                    info.verts = temp;                                        for (var v = 0; v < verts.length; v++)                    {                       temp.push([                                            verts[v][0]+layer_trans_pos[0]-layer_trans_anchor[0]+shape_trans_pos[0]-shape_trans_anchor[0],                                            verts[v][1]+layer_trans_pos[1]-layer_trans_anchor[1]+shape_trans_pos[1]-shape_trans_anchor[1]                                        ])                                            }                                        ret_list.push(info);                                    }                catch (e) {}                            }        }    }    return ret_list;}function shape_collision(){     var comp = app.project.activeItem;    var shape_layer = comp.selectedLayers[0];    var target_layer = comp.selectedLayers[1];    var pos = target_layer.position.value;        var verts = get_verts(shape_layer)    var is_inside = false;        for (var i = 0; i < verts.length; i++)    {        var info = verts[i]        var name = info.name;        var vs = info.verts;                is_inside = shape_collision(pos, vs);        alert(is_inside)        /*        for (var j = 0; j < verts.length; j++)        {            //$.writeln(arr[j])            //nu = comp.layers.addNull();            //nu.name = name+"_v"+j;            //nu.Transform.Position.setValue([verts[j][0], verts[j][1]]);        }        */    }}shape_intersection()