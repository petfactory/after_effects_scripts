function inside(point, vs){    // ray-casting algorithm based on    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html        var x = point[0], y = point[1];        var inside = false;    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {        var xi = vs[i][0], yi = vs[i][1];        var xj = vs[j][0], yj = vs[j][1];                var intersect = ((yi > y) != (yj > y))            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);        if (intersect) inside = !inside;    }        return inside;};function get_verts(shape_layer){    var ret_list = []     // Iterate over the shape layer's paths, converting them to masks    var shapeContents = shape_layer.property("ADBE Root Vectors Group");        for (var g=1; g<=shapeContents.numProperties; g++)    {        shapeGroup = shapeContents.property(g);                // Only process groups        if (shapeGroup.matchName !== "ADBE Vector Group") continue;                shape_trans_pos = shapeGroup.property("ADBE Vector Transform Group").property("ADBE Vector Position").value;        shape_trans_anchor = shapeGroup.property("ADBE Vector Transform Group").property("ADBE Vector Anchor").value;        layer_trans_pos = shape_layer.transform.position.value;        layer_trans_anchor = shape_layer.transform.anchorPoint.value;                    // Look in each group for shape paths. These will be converted to masks        shapeGroupContents = shapeGroup.property("Contents");                for (var gp=1; gp<=shapeGroupContents.numProperties; gp++)        {            shapeGroupProp = shapeGroupContents.property(gp);            if (shapeGroupProp.matchName === "ADBE Vector Shape - Group")            {                try                {                    // Get the shape path info                    shapePath = shapeGroupProp.property("ADBE Vector Shape");                    var verts = shapePath.value.vertices;                                        var info = {};                    info.name = shapeGroup.name;                    var temp = [];                    info.verts = temp;                    info.shape_grp = shapeGroup;                                        for (var v = 0; v < verts.length; v++)                    {                       temp.push([                                            verts[v][0]+layer_trans_pos[0]-layer_trans_anchor[0]+shape_trans_pos[0]-shape_trans_anchor[0],                                            verts[v][1]+layer_trans_pos[1]-layer_trans_anchor[1]+shape_trans_pos[1]-shape_trans_anchor[1]                                        ])                                            }                                        ret_list.push(info);                                    }                catch (e) {}            }        }    }    return ret_list;}function step_timeline(comp){         var fps = comp.frameRate;    var time_step = 1.0/fps;    var start_time = comp.workAreaStart ;    var duration = comp.workAreaDuration;    var end_time= start_time + duration;    var start_frame = Math.floor(start_time*fps);    var end_frame = Math.floor(end_time*fps);    var total_frames = Math.floor(duration*fps);        return ({"start_frame":start_frame, "end_frame":end_frame, "time_step":time_step});}function anim_layer_opacity(){    var comp = app.project.activeItem;    var shape_layer = comp.selectedLayers[0];    var target_layer = comp.selectedLayers[1];        stepper = step_timeline(comp);    var start_frame = stepper.start_frame;    var end_frame = stepper.end_frame;    var time_step = stepper.time_step;        var verts = get_verts(shape_layer)         var time, pos, is_inside;    for (var i = start_frame; i < end_frame+1; i++)    {        time = time_step * i;        pos = target_layer.position.valueAtTime(time, false);        //$.writeln(pos);                is_inside = false;        for (var j = 0; j < verts.length; j++)        {            var info = verts[j]            var name = info.name;            var vs = info.verts;            is_inside = inside(pos, vs);                        if (is_inside) break;        }                //$.writeln(is_inside);            if (is_inside)            {                 shape_layer.opacity.setValueAtTime(time, 30)            }            else shape_layer.opacity.setValueAtTime(time, 100)    }}//anim_layer_opacity();function test(){    var comp = app.project.activeItem;        var stepper = step_timeline(comp);    var start_frame = stepper.start_frame;    var end_frame = stepper.end_frame;    var time_step = stepper.time_step;        var shape_layer = comp.selectedLayers[0];    var target_layer = comp.selectedLayers[1];        var info_list = get_verts(shape_layer);    var info_len = info_list.length;    // initiate opacity values    var val_list = []    for (var i = start_frame; i < info_len; i++) val_list.push(100);    // show progress ui    var w = new Window ('palette');    w.pbar = w.add ('progressbar', undefined, 0, end_frame-start_frame);    w.pbar.preferredSize.width = 300;    w.show();    var time, pos, is_inside;    for (var i = start_frame; i < end_frame+1; i++)    {        time = time_step * i;        for (var j = 0; j < info_len; j++)        {            var shape_grp = info_list[j].shape_grp;            opacity = shape_grp.property("ADBE Vector Transform Group").property("ADBE Vector Group Opacity");            //opacity.setValueAtTime(time, Math.min(100, i));                        pos = target_layer.position.valueAtTime(time, false);            is_inside = inside(pos, info_list[j].verts);                        //$.writeln(is_inside);            if (is_inside)            {                 //opacity.setValueAtTime(time, 30);                 if (val_list[j] > 0) val_list[j]-=10;            }            else            {                //opacity.setValueAtTime(time, 100);                if (val_list[j] < 100) val_list[j]+=10;            }            opacity.setValueAtTime(time, val_list[j]);        }        // inc the progressbar        w.pbar.value = i+1;    }    w.close();}test();